[{"title":"循环问题","date":"2018-12-20T10:41:50.000Z","path":"2018/12/20/循环问题/","text":"有关循环的一些语法 1.foreach与map的异同点 (1) map定义和用法：： map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。 我的理解就是：原数组进行处理之后对应的一个新的数组。 map()方法按照原始数组元素顺序依次处理元素。 注意：map()方法不会对空数组进行检测。 map()方法不会改变原始数组。 1array.map(function(item,index,arr)&#123;&#125;,thisValue) (2)foreach定义和用法 ： forEach()方法用于调用数组的每个元素，将元素传给回调函数。 注意：forEach对于空数组是不会调用回调函数的。1Array.forEach(function(item,index,arr)&#123;&#125;,this)","tags":[{"name":"js es6","slug":"js-es6","permalink":"http://yoursite.com/tags/js-es6/"}]},{"title":"git命令学习","date":"2018-12-15T06:41:33.000Z","path":"2018/12/15/git学习/","text":"git学习 1. git错误归纳1.1 运行 $ git remote add origin git@github.com:yourName/yourRepo.git命令时提示下面的错误： 1234fatal: Not a git repository (or any of the parent directories): .git 提示说没有.git这样一个目录。 解决办法如下：运行git init 然后在运行git remote add origin git@github.com:yourName/yourRepo.git 1.2 git push报错error: failed to push some refs to &#39;git@github.com：12345原因： GitHub远程仓库中的README.md文件不在本地仓库中。 解决方案：$ git pull --rebase origin master$ git push -u origin master 2.git命令2.1 git删除某次指定的提交:reset命令有3种方式：(1)git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息(2)git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可(3)git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容 2.2 git fetch和git pull的差别 (1)git fetch 相当于是从远程获取最新到本地，不会自动merge (2)git pull：相当于是从远程获取最新版本并merge到本地,在实际使用中，git fetch更安全一些。 2.3 rebase 和 merge的区别 (1)git merge origin就是将你现在的local branch 和远程跟踪库remote tracked repo合并, 并形成一个的commit(也就是一个true merge)。 (2)git rebase origin master rebase就是可以把分支的祖先强行改变,可以把master分支自上次拉取或上次提交后做的提交, 全部拿出来在origin上重新跑(run)一遍, 你的master分支的历史就没了, 而且注意一点, git中每个提交(commit)有一个独一无二的hash码, rebase命令会为每个新增(相对origin来说)的提交重新生成一个hash码.可以看出merge结果能够体现出时间线，但是rebase会打乱时间线。","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"vue学习","date":"2018-12-06T06:41:33.000Z","path":"2018/12/06/vue学习/","text":"vue学习总结 1. Vue模板： 123&lt;template&gt;vue代码&lt;/template&gt;&lt;script&gt;JS代码&lt;/script&gt;&lt;style scoped&gt;css样式&lt;/style&gt; scoped:定义样式只在当前组件内生效 生命周期钩子函数： created 钩子可以用来在一个实例被创建之后执行代码：其他函数如 mounted、updated 和 destroyed。 2. 模板语法：1234567891011121314151617（1）Mustache语法 双大括号&#123;&#123;&#125;&#125;进行数据绑定，注意大括号里面只能为单行语句,不能作用在html属性上 （2）v-html和v-text &lt;p v-html=&quot;hello&quot;&gt;&lt;/p&gt;这个可以解析html语法而v-text会直接显示文本， &lt;p v-text=&quot;hello&quot;&gt;&lt;/p&gt; 在&lt;script&gt;部分的data()函数中声明：hello:&quot;&lt;p&gt;hello vue&lt;/p&gt;&quot; （3）v-bind 动态绑定，在下面函数声明属性，样式动态改变。 缩写形式：&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt; &lt;span v-bind:class=&quot;ha&quot; v-bind:id=&quot;bi&quot;&gt;哈哈哈哈&lt;/span&gt; data()函数部分： ha:&quot;ha1&quot;, bi:&quot;bt&quot;, style样式部分: .ha1&#123;color:blue;&#125; #bi&#123;font-size:50px;&#125; 3. 条件渲染： 1234567（1）v-if 和v-else。当v-if属性为ture时才显示，否则显示v-else,则属性为false, v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 &lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;（2）v-show v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 4.列表渲染12345678（1）v-forv-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。v-for 还支持一个可选的第二个参数为当前项的索引。&lt;ul&gt; &lt;li v-for=&quot;(urse,index) in urses&quot;&gt;&#123;&#123;urse&#125;&#125;-&#123;&#123;index&#125;&#125;&lt;/li&gt;&lt;/ul&gt;data()函数部分:urses:[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;],","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]}]