[{"title":"循环问题","date":"2018-12-20T10:41:50.000Z","path":"2018/12/20/循环问题/","text":"有关循环的一些语法 1.foreach与map的异同点 (1) map定义和用法：： map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。 我的理解就是：原数组进行处理之后对应的一个新的数组。 map()方法按照原始数组元素顺序依次处理元素。 注意：map()方法不会对空数组进行检测。 map()方法不会改变原始数组。 1array.map(function(item,index,arr)&#123;&#125;,thisValue) (2)foreach定义和用法 ： forEach()方法用于调用数组的每个元素，将元素传给回调函数。 注意：forEach对于空数组是不会调用回调函数的。1Array.forEach(function(item,index,arr)&#123;&#125;,this)","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"git命令学习","date":"2018-12-15T06:41:33.000Z","path":"2018/12/15/git学习/","text":"git学习 1. git错误归纳1.1 运行 $ git remote add origin git@github.com:yourName/yourRepo.git命令时提示下面的错误： 1234fatal: Not a git repository (or any of the parent directories): .git 提示说没有.git这样一个目录。 解决办法如下：运行git init 然后在运行git remote add origin git@github.com:yourName/yourRepo.git 1.2 git push报错error: failed to push some refs to &#39;git@github.com：12345原因： GitHub远程仓库中的README.md文件不在本地仓库中。 解决方案：$ git pull --rebase origin master$ git push -u origin master 2.git命令2.1 git删除某次指定的提交:reset命令有3种方式：(1)git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息(2)git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可(3)git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容 2.2 git fetch和git pull的差别 (1)git fetch 相当于是从远程获取最新到本地，不会自动merge (2)git pull：相当于是从远程获取最新版本并merge到本地,在实际使用中，git fetch更安全一些。 2.3 rebase 和 merge的区别 (1)git merge origin就是将你现在的local branch 和远程跟踪库remote tracked repo合并, 并形成一个的commit(也就是一个true merge)。 (2)git rebase origin master rebase就是可以把分支的祖先强行改变,可以把master分支自上次拉取或上次提交后做的提交, 全部拿出来在origin上重新跑(run)一遍, 你的master分支的历史就没了, 而且注意一点, git中每个提交(commit)有一个独一无二的hash码, rebase命令会为每个新增(相对origin来说)的提交重新生成一个hash码.可以看出merge结果能够体现出时间线，但是rebase会打乱时间线。 3.git命令使用(1)：git init 创建一个工作区 该工作区包含一个.git目录其中如果在这个工作区外面有创建了一个工作区也就是有执行了这个git init这个时候就会有个.git目录（也就是里存在版本控制文件目录）这个时候git会查找最近的那个.git目录(2)：git add a.txt 加入暂存区 git add . 表示所有的这个文件都加入到暂存区(3)：git status/git st(可以自己定义别名) 查看当前版本库状态(4)：git commit -m”注释” 提交注释(5)：git hist 可以查看到所有的分支和当前分支也可以查询处是谁提交的代码(6)：git commit -a -m”committ3” 跳过git add .(.代表当前) 不推荐使用(7)：git log查看日志(8)：git config自定义命令：ex：git st/git co(checkout)(9)：git diff (没有git add之前得对比)表示上一次和本次修改之后的差异(并没有放到暂存区里面)(10)：git diff -head (没有git add之前得对比) head表示当前的分支&lt;类似于游标&gt;(比如master也就是主分支当前的版本库)也就是这个分支最后的一次提交产生的版本库(11)：git status -s 有时候会显示出两个MM，当执行git diff时但是没有执行git add .之前 会在第二列出现M表示的是当前文档(修改之后的文件)和工作区有差异(就是刚才修改之前得按个文件)当执行了git add .但是没有执行git commit -m时就会在第一类出现一个M表示当前的版本库(也就是提交上去的按个版本)和中间状态有差异(中间绿色的那个)(12)：git add . 暂存区的用处:当我们开发完一个功能之后可能add一下，但是不要提交，然后在去代码上测试功能(日志,输出语句等)最后使用git checkout a.txt就可以撤销刚才的那些测试代码，然后功能代码(13)：git branch查看当前分支(14)：git branch mydev 创建分支(15)：git checkout mydev 切换分支(16)：git reset a.txt 从暂存区撤销 然后可执行git checkout a.txt 回到原点当我们创建另外的一个分支是，并在另外一个分支做文件修改之后(还没有提交，也没有放到暂存区,但是也可以放到暂存区中)，然后上一个分支说有问题了这个时候就必须切换到上一个分支，然后保证这个分支是nothing to commit状态就可以了，但是会发现上一个分支也产生了modified:a.txt的状态，所以就要切换到另外一个分支，然后使用这个命令git stash 临时保存这个文件，然后切换回去提交上一个分支就没有问题了，然后在回到另一个分支继续开发(吵架)发现切换(17)：git stash临时保存修改的文件(18)：git stash pop 然后在打开分支的进行操作(提交啊撤销啊等)(19)：git reset –hard 版本名称(使用git hist可以看到) 粗鲁的撤销到某个版本(20)：git reflog查看所有的分支的版本信息（粗鲁的回去）(21)：git reflog master查看指定master分支下的版本信息（注意{0}{1}{2}代表的从上到下是最新的版本）(22)：git reset –hard master{1} 粗鲁的回到master分支的第二个版本，但是中间的修改将会丢失了(23)：git reset 文件名称/文件路径 表示的是撤销某个文件/撤销整个目录下的文件(24)：git push origin master 讲项目推送到github上(25)：git checkout 版本号(使用git hist可查看) 表示我要回退到这个版本，做了修改之后再合并(26)：git branch -v查看分支 如果有一个信息显示no branch表示分离头指针","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"vue学习","date":"2018-12-06T06:41:33.000Z","path":"2018/12/06/vue学习/","text":"vue学习总结 1. Vue模板： 123&lt;template&gt;vue代码&lt;/template&gt;&lt;script&gt;JS代码&lt;/script&gt;&lt;style scoped&gt;css样式&lt;/style&gt; scoped:定义样式只在当前组件内生效 生命周期钩子函数： created 钩子可以用来在一个实例被创建之后执行代码：其他函数如 mounted、updated 和 destroyed。 2. 模板语法：1234567891011121314151617（1）Mustache语法 双大括号&#123;&#123;&#125;&#125;进行数据绑定，注意大括号里面只能为单行语句,不能作用在html属性上 （2）v-html和v-text &lt;p v-html=&quot;hello&quot;&gt;&lt;/p&gt;这个可以解析html语法而v-text会直接显示文本， &lt;p v-text=&quot;hello&quot;&gt;&lt;/p&gt; 在&lt;script&gt;部分的data()函数中声明：hello:&quot;&lt;p&gt;hello vue&lt;/p&gt;&quot; （3）v-bind 动态绑定，在下面函数声明属性，样式动态改变。 缩写形式：&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt; &lt;span v-bind:class=&quot;ha&quot; v-bind:id=&quot;bi&quot;&gt;哈哈哈哈&lt;/span&gt; data()函数部分： ha:&quot;ha1&quot;, bi:&quot;bt&quot;, style样式部分: .ha1&#123;color:blue;&#125; #bi&#123;font-size:50px;&#125; 3. 条件渲染： 1234567（1）v-if 和v-else。当v-if属性为ture时才显示，否则显示v-else,则属性为false, v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 &lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;（2）v-show v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 4.列表渲染12345678（1）v-forv-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。v-for 还支持一个可选的第二个参数为当前项的索引。&lt;ul&gt; &lt;li v-for=&quot;(urse,index) in urses&quot;&gt;&#123;&#123;urse&#125;&#125;-&#123;&#123;index&#125;&#125;&lt;/li&gt;&lt;/ul&gt;data()函数部分:urses:[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;],","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"JS问题","date":"2018-01-14T20:30:50.000Z","path":"2018/01/15/js/","text":"1.apply()与call()的区别apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。不同之处：call可以传入多个参数；apply只能传入两个参数，所以其第二个参数往往是作为数组形式传入。 2.array.sortsort() 方法用于对数组的元素进行排序。对数组的引用。请注意，数组在原数组上进行排序，不生成副本。如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，是按照字符编码的顺序进行排序。如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。简单点：比较函数两个参数a和b，返回a-b升序，返回b-a降序1234567var arr = [4,3,6,5,7,2,1];arr.sort();arr.sort(function(a,b)&#123; return b-a;&#125;);console.log(arr);//输出结果[7,6,5,4,3,2,1]","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"css属性问题","date":"2018-01-08T18:30:50.000Z","path":"2018/01/09/css/","text":"有关CSS3的一些属性 1.input输入默认值placeholder属性。在输入框为空的情况下会显示placeholder中的值。但是提交时不能直接取其值。value属性。在输入框加载的时候输入框中的值。提交时可直接获取。 (1) 使用onfocus事件： 如果是默认值,就将value属性置空.如: 1&lt;input type=&quot;text&quot; value=&quot;请输入内容&quot; onfocus=&quot;javascript:if(this.value==&apos;请输入内容&apos;)this.value=&apos;&apos;;&quot;&gt; (2)placeholder=”这里输入文字” ：1&lt;input id=&quot;email&quot; type=&quot;text&quot; placeholder=&quot;这里输入文字&quot; size=&quot;22&quot; /&gt; 2.position 的属性 position的含义是指定位类型，取值类型可以有：static、relative、absolute、fixed、inherit和sticky，这里sticky是CSS3新发布的一个属性。(1)inherit继承父元素的position属性;(2)position属性设置了sticky的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。 3.box-sizing 属性box-sizing 属性可以被用来调整这些表现:content-box:是默认值。如果设置一个元素的宽为100px，那么这个元素的内容区会有100px宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。border-box:告诉浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding的计算值。 4.vertical-align 属性vertical-align 属性设置元素的垂直对齐方式。该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。属性示意图如下： 5.CSS清除浮动(1)父级div定义 height(2)结尾处加空div标签 clear:both(3)父级div定义 伪类:after注意样式属性：12345.clearfloat:after &#123; /* 这三句必须写 */ display:block; clear:both; content:&quot;&quot;; (4)父级div定义 overflow:hidden(5)父级div 也一起浮动(6)父级div定义 display:table将div转化为表格","tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]}]